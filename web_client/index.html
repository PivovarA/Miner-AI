<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Treasure Hunter Game</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #gameCanvas {
            border: 2px solid #333;
            background-color: #fff;
        }
        #gameInfo {
            margin-top: 10px;
            font-size: 18px;
        }
        #controls {
            margin-top: 10px;
        }
        #gameOver {
            display: none;
            font-size: 24px;
            font-weight: bold;
            color: red;
            margin-top: 20px;
        }
        #serverStatus {
            font-size: 16px;
            color: blue;
            margin-top: 10px;
        }
        #playerSettings {
            margin-bottom: 10px;
            padding: 10px;
            background: #e0e0e0;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div id="playerSettings">
        <label>
            <input type="checkbox" id="enablePlayer" onchange="togglePlayer()"> Enable Human Player
        </label>
        <label style="margin-left: 20px;">
            <input type="checkbox" id="collectData" checked> Collect Player Data
        </label>
        <label style="margin-left: 20px;">
            Player Name: <input type="text" id="playerName" value="player1">
        </label>
    </div>
    
    <canvas id="gameCanvas" width="800" height="800"></canvas>
    <div id="gameInfo">
        <div id="botsInfo"></div>
        <div>Treasures Remaining: <span id="remainingTreasures">5</span></div>
        <div>Time Remaining: <span id="timeRemaining">60</span>s</div>
        <div id="devMode" style="color: blue;">DEVELOPER MODE: ON</div>
    </div>
    <div id="controls">
        <p>Controls: Arrow keys to move, Space to drop trap, E to explode traps</p>
        <button id="restartButton" style="font-size: 18px; padding: 10px 20px; margin-top: 10px;">Restart Game</button>
    </div>
    <div id="gameOver"></div>
    <div id="serverStatus"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const tileSize = 20;
        const gridWidth = canvas.width / tileSize;
        const gridHeight = canvas.height / tileSize;
        const maxTraps = 10;
        const visionDistance = 10;
        const visionAngle = 60 * Math.PI / 180; // 60 degrees in radians
        const explosionRadius = 5;
        const DEVELOPER_MODE = false; // Set to false to hide everything outside vision
        const USE_SERVER_BOT = true; // Set to true to use Python server for bot control
        let DISABLE_PLAYER = true; // Will be controlled by checkbox
        const NUM_BOTS = 4; // Number of bots to spawn
        const GAME_DURATION = 120000; // Game duration in milliseconds (60 seconds)
        const SERVER_URL = 'http://localhost:5001';
        const EXPLOSION_DURATION = 1000; // Explosion animation duration in milliseconds

        let gameRunning = true;
        let gameActive = true; // New flag to control actual gameplay
        let obstacles = [];
        let treasures = [];
        let bots = [];
        let botTraps = [];
        let playerTraps = [];
        let frameCount = 0;
        let gameStartTime = Date.now();
        let waitingForServer = false;
        let serverResponses = 0;
        let activeExplosions = [];
        
        // Player data collection
        let collectPlayerData = true;
        let playerSessionData = [];
        let sessionStartTime = null;
        
        // Player object
        const player = {
            x: 0,
            y: 0,
            direction: 0, // 0 = right, PI/2 = up, PI = left, 3PI/2 = down
            treasures: 0,
            remainingTraps: maxTraps,
            alive: true
        };
        
        // Toggle player functionality
        function togglePlayer() {
            DISABLE_PLAYER = !document.getElementById('enablePlayer').checked;
            if (!DISABLE_PLAYER && gameRunning) {
                spawnPlayer();
                if (collectPlayerData && !sessionStartTime) {
                    startDataCollection();
                }
            }
        }
        
        // Initialize data collection session
        function startDataCollection() {
            if (!collectPlayerData || DISABLE_PLAYER) return;
            
            const playerName = document.getElementById('playerName').value || 'player1';
            sessionStartTime = Date.now();
            playerSessionData = [];
            
            console.log(`Starting data collection for player: ${playerName}`);
        }
        
        // Record player action
        function recordPlayerAction(action) {
            if (!collectPlayerData || DISABLE_PLAYER || !sessionStartTime) return;
            
            const gameState = getPlayerGameState();
            const record = {
                timestamp: Date.now() - sessionStartTime,
                state: gameState,
                action: action,
                position: { x: player.x, y: player.y },
                direction: player.direction,
                treasures: player.treasures,
                remainingTraps: player.remainingTraps
            };
            
            playerSessionData.push(record);
        }
        
        // Get game state from player's perspective
        function getPlayerGameState() {
            const visibleTreasures = [];
            const visibleBots = [];
            const visibleTraps = [];
            
            // Get visible treasures
            for (let treasure of treasures) {
                if (!treasure.collected && isInVisionCone(player, treasure.x, treasure.y)) {
                    visibleTreasures.push({
                        x: treasure.x - player.x,
                        y: treasure.y - player.y
                    });
                }
            }
            
            // Get visible bots
            for (let i = 0; i < bots.length; i++) {
                if (bots[i].alive && isInVisionCone(player, bots[i].x, bots[i].y)) {
                    visibleBots.push({
                        id: i,
                        x: bots[i].x - player.x,
                        y: bots[i].y - player.y,
                        treasures: bots[i].treasures,
                        traps_remaining: bots[i].remainingTraps
                    });
                }
            }
            
            // Get visible traps
            for (let trap of playerTraps) {
                if (isInVisionCone(player, trap.x, trap.y)) {
                    visibleTraps.push({
                        x: trap.x - player.x,
                        y: trap.y - player.y,
                        owner: 'self'
                    });
                }
            }
            
            // Get visible obstacles
            const visibleObstacles = [];
            for (let obstacle of obstacles) {
                for (let ox = obstacle.x; ox < obstacle.x + obstacle.width; ox++) {
                    for (let oy = obstacle.y; oy < obstacle.y + obstacle.height; oy++) {
                        if (isInVisionCone(player, ox, oy)) {
                            visibleObstacles.push({
                                x: ox - player.x,
                                y: oy - player.y
                            });
                        }
                    }
                }
            }
            
            // Calculate scores for all participants
            const allScores = [];
            if (!DISABLE_PLAYER) {
                allScores.push({
                    id: 'player',
                    treasures: player.treasures,
                    alive: player.alive
                });
            }
            for (let bot of bots) {
                allScores.push({
                    id: bot.id,
                    treasures: bot.treasures,
                    alive: bot.alive
                });
            }
            
            return {
                bot_id: 'player',
                bot_position: { x: player.x, y: player.y },
                bot_direction: player.direction,
                bot_treasures: player.treasures,
                bot_remaining_traps: player.remainingTraps,
                bot_alive: player.alive,
                total_treasures: treasures.length,
                treasures_collected: treasures.filter(t => t.collected).length,
                visible_treasures: visibleTreasures,
                visible_bots: visibleBots,
                visible_traps: visibleTraps,
                visible_obstacles: visibleObstacles,
                bot_scores: allScores,
                time_remaining: Math.max(0, GAME_DURATION - (Date.now() - gameStartTime)),
                game_over: !gameRunning,
                explosions_available: playerTraps.length > 0
            };
        }
        
        // End data collection session
        function endDataCollection(won) {
            if (!collectPlayerData || DISABLE_PLAYER || !sessionStartTime || playerSessionData.length === 0) return;
            
            const playerName = document.getElementById('playerName').value || 'player1';
            const sessionData = {
                player_name: playerName,
                session_start: sessionStartTime,
                session_end: Date.now(),
                duration: Date.now() - sessionStartTime,
                final_score: player.treasures * 10 + (player.alive ? 20 : 0),
                treasures_collected: player.treasures,
                survived: player.alive,
                won: won,
                actions: playerSessionData
            };
            
            // Send data to server
            if (USE_SERVER_BOT) {
                fetch(`${SERVER_URL}/save_player_data`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(sessionData)
                })
                .then(response => response.json())
                .then(data => {
                    console.log('Player data saved:', data);
                })
                .catch(error => {
                    console.error('Error saving player data:', error);
                    // Fallback: save locally
                    localStorage.setItem(`player_session_${Date.now()}`, JSON.stringify(sessionData));
                });
            }
            
            // Reset session data
            playerSessionData = [];
            sessionStartTime = null;
        }
        
        // Create multiple bots
        function createBots() {
            bots = [];
            botTraps = [];
            
            for (let i = 0; i < NUM_BOTS; i++) {
                const bot = {
                    id: i,
                    x: 0,
                    y: 0,
                    direction: 0,
                    treasures: 0,
                    remainingTraps: maxTraps,
                    alive: true,
                    color: `hsl(${i * 360 / NUM_BOTS}, 70%, 50%)`, // Different colors for each bot
                    memory: {
                        lastSeenTreasure: null,
                        lastSeenBots: []
                    }
                };
                bots.push(bot);
                botTraps.push([]); // Each bot has its own trap array
            }
        }

        // Initialize game
        function init() {
            // Reset game state
            gameRunning = true;
            gameActive = true;
            waitingForServer = false;
            serverResponses = 0;
            obstacles = [];
            treasures = [];
            playerTraps = [];
            activeExplosions = [];
            frameCount = 0;
            gameStartTime = Date.now();
            
            // Reset player
            player.x = 0;
            player.y = 0;
            player.direction = 0;
            player.treasures = 0;
            player.remainingTraps = maxTraps;
            player.alive = true;
            
            // Create bots
            createBots();
            
            // Hide game over message
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('serverStatus').textContent = '';
            
            // Generate new game
            generateObstacles();
            if (!DISABLE_PLAYER) {
                spawnPlayer();
            }
            spawnBots();
            spawnTreasures();
            updateUI();
            
            // Start data collection if enabled
            if (!DISABLE_PLAYER && collectPlayerData) {
                startDataCollection();
            }
            
            gameLoop();
        }

        // Generate random obstacles
        function generateObstacles() {
            const numObstacles = 50;
            for (let i = 0; i < numObstacles; i++) {
                const width = Math.floor(Math.random() * 3) + 1;
                const height = Math.floor(Math.random() * 3) + 1;
                const x = Math.floor(Math.random() * (gridWidth - width));
                const y = Math.floor(Math.random() * (gridHeight - height));
                obstacles.push({ x, y, width, height });
            }
        }

        // Spawn player at random location
        function spawnPlayer() {
            do {
                player.x = Math.floor(Math.random() * gridWidth);
                player.y = Math.floor(Math.random() * gridHeight);
            } while (isColliding(player.x, player.y));
        }

        // Spawn bots at random locations
        function spawnBots() {
            for (let bot of bots) {
                do {
                    bot.x = Math.floor(Math.random() * gridWidth);
                    bot.y = Math.floor(Math.random() * gridHeight);
                } while (isColliding(bot.x, bot.y) || isTooCloseToOtherBots(bot));
            }
        }

        // Check if bot is too close to other bots
        function isTooCloseToOtherBots(currentBot) {
            for (let otherBot of bots) {
                if (otherBot !== currentBot) {
                    const distance = Math.sqrt(Math.pow(otherBot.x - currentBot.x, 2) + Math.pow(otherBot.y - currentBot.y, 2));
                    if (distance < 10) return true;
                }
            }
            return false;
        }

        // Spawn treasures
        function spawnTreasures() {
            const numTreasures = 5;
            for (let i = 0; i < numTreasures; i++) {
                let treasure;
                do {
                    treasure = {
                        x: Math.floor(Math.random() * gridWidth),
                        y: Math.floor(Math.random() * gridHeight),
                        collected: false
                    };
                } while (isColliding(treasure.x, treasure.y));
                treasures.push(treasure);
            }
        }

        // Check if position collides with obstacles
        function isColliding(x, y) {
            for (let obstacle of obstacles) {
                if (x >= obstacle.x && x < obstacle.x + obstacle.width &&
                    y >= obstacle.y && y < obstacle.y + obstacle.height) {
                    return true;
                }
            }
            return false;
        }

        // Ray casting for line of sight
        function hasLineOfSight(x1, y1, x2, y2) {
            // Bresenham's line algorithm
            let dx = Math.abs(x2 - x1);
            let dy = Math.abs(y2 - y1);
            let sx = x1 < x2 ? 1 : -1;
            let sy = y1 < y2 ? 1 : -1;
            let err = dx - dy;

            let x = x1;
            let y = y1;

            while (x !== x2 || y !== y2) {
                // Check if current position hits an obstacle
                if (isColliding(x, y) && !(x === x1 && y === y1)) {
                    return false;
                }

                let e2 = 2 * err;
                if (e2 > -dy) {
                    err -= dy;
                    x += sx;
                }
                if (e2 < dx) {
                    err += dx;
                    y += sy;
                }
            }

            return true;
        }

        // Check if point is in vision cone with line of sight
        function isInVisionCone(viewer, targetX, targetY) {
            const dx = targetX - viewer.x;
            const dy = targetY - viewer.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance > visionDistance) return false;
            
            const angleToTarget = Math.atan2(dy, dx);
            let angleDiff = Math.abs(angleToTarget - viewer.direction);
            
            if (angleDiff > Math.PI) {
                angleDiff = 2 * Math.PI - angleDiff;
            }
            
            // Check if target is within vision angle
            if (angleDiff > visionAngle / 2) return false;
            
            // Check line of sight
            return hasLineOfSight(viewer.x, viewer.y, targetX, targetY);
        }

        // Move entity
        function move(entity, dx, dy) {
            const newX = entity.x + dx;
            const newY = entity.y + dy;
            
            if (newX >= 0 && newX < gridWidth && newY >= 0 && newY < gridHeight && !isColliding(newX, newY)) {
                entity.x = newX;
                entity.y = newY;
                return true;
            }
            return false;
        }

        // Update direction based on movement
        function updateDirection(entity, dx, dy) {
            if (dx === 1) entity.direction = 0;
            else if (dx === -1) entity.direction = Math.PI;
            else if (dy === -1) entity.direction = 3 * Math.PI / 2;  // Up
            else if (dy === 1) entity.direction = Math.PI / 2;      // Down
        }

        // Get game state for a specific bot
        function getGameState(botIndex) {
            const bot = bots[botIndex];
            const visibleTreasures = [];
            const visibleBots = [];
            const visibleTraps = [];
            
            // Get visible treasures
            for (let treasure of treasures) {
                if (!treasure.collected && isInVisionCone(bot, treasure.x, treasure.y)) {
                    visibleTreasures.push({
                        x: treasure.x - bot.x,
                        y: treasure.y - bot.y
                    });
                }
            }
            
            // Get visible other bots
            for (let i = 0; i < bots.length; i++) {
                if (i !== botIndex && bots[i].alive && isInVisionCone(bot, bots[i].x, bots[i].y)) {
                    visibleBots.push({
                        id: i,
                        x: bots[i].x - bot.x,
                        y: bots[i].y - bot.y,
                        treasures: bots[i].treasures,
                        traps_remaining: bots[i].remainingTraps
                    });
                }
            }
            
            // Check if player is visible
            if (!DISABLE_PLAYER && player.alive && isInVisionCone(bot, player.x, player.y)) {
                visibleBots.push({
                    id: 'player',
                    x: player.x - bot.x,
                    y: player.y - bot.y,
                    treasures: player.treasures,
                    traps_remaining: player.remainingTraps
                });
            }
            
            // Get visible own traps (for strategic planning)
            for (let trap of botTraps[botIndex]) {
                if (isInVisionCone(bot, trap.x, trap.y)) {
                    visibleTraps.push({
                        x: trap.x - bot.x,
                        y: trap.y - bot.y,
                        owner: 'self'
                    });
                }
            }
            
            // Get visible obstacles
            const visibleObstacles = [];
            for (let obstacle of obstacles) {
                for (let ox = obstacle.x; ox < obstacle.x + obstacle.width; ox++) {
                    for (let oy = obstacle.y; oy < obstacle.y + obstacle.height; oy++) {
                        if (isInVisionCone(bot, ox, oy)) {
                            visibleObstacles.push({
                                x: ox - bot.x,
                                y: oy - bot.y
                            });
                        }
                    }
                }
            }
            
            // Calculate scores for all bots
            const botScores = bots.map(b => ({
                id: b.id,
                treasures: b.treasures,
                alive: b.alive
            }));
            
            if (!DISABLE_PLAYER) {
                botScores.push({
                    id: 'player',
                    treasures: player.treasures,
                    alive: player.alive
                });
            }
            
            return {
                bot_id: botIndex,
                bot_position: { x: bot.x, y: bot.y },
                bot_direction: bot.direction,
                bot_treasures: bot.treasures,
                bot_remaining_traps: bot.remainingTraps,
                bot_alive: bot.alive,
                total_treasures: treasures.length,
                treasures_collected: treasures.filter(t => t.collected).length,
                visible_treasures: visibleTreasures,
                visible_bots: visibleBots,
                visible_traps: visibleTraps,
                visible_obstacles: visibleObstacles,
                bot_scores: botScores,
                time_remaining: Math.max(0, GAME_DURATION - (Date.now() - gameStartTime)),
                game_over: !gameRunning,
                explosions_available: bot.remainingTraps > 0 ? botTraps[botIndex].length > 0 : false
            };
        }

// Update all bots from server
async function updateBotsFromServer() {
            // Immediately return if game is not active or waiting for server
            if (!USE_SERVER_BOT || waitingForServer || !gameActive || !gameRunning) return;

            // Only update bots every N frames to make them slower
            if (frameCount % 10 !== 0) return;

            // Double-check that the game is still active
            if (!gameActive || !gameRunning) return;

            // Update each bot
            for (let i = 0; i < bots.length; i++) {
                const bot = bots[i];
                if (!bot.alive) continue;

                try {
                    const gameState = getGameState(i);
                    
                    const response = await fetch(`${SERVER_URL}/get_action`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(gameState)
                    });
                    
                    const data = await response.json();
                    const action = data.action;
                    
                    // Execute action only if game is still active
                    if (gameActive && gameRunning) {
                        switch(action) {
                            case 'move_up':
                                if (move(bot, 0, -1)) updateDirection(bot, 0, -1);
                                break;
                            case 'move_down':
                                if (move(bot, 0, 1)) updateDirection(bot, 0, 1);
                                break;
                            case 'move_left':
                                if (move(bot, -1, 0)) updateDirection(bot, -1, 0);
                                break;
                            case 'move_right':
                                if (move(bot, 1, 0)) updateDirection(bot, 1, 0);
                                break;
                            case 'drop_trap':
                                dropTrap(bot, botTraps[i]);
                                break;
                            case 'explode_traps':
                                explodeTraps(bot, botTraps[i]);
                                break;
                            case 'wait':
                                // Do nothing
                                break;
                        }
                    }
                    
                } catch (error) {
                    console.error('Error communicating with server:', error);
                }
            }
        }

        // Drop trap
        function dropTrap(entity, trapArray) {
            if (entity.remainingTraps > 0) {
                trapArray.push({ x: entity.x, y: entity.y, owner: entity });
                entity.remainingTraps--;
                updateUI();
            }
        }

        // Explode traps
        function explodeTraps(entity, trapArray) {
            for (let trap of trapArray) {
                // Create explosion animation
                activeExplosions.push({
                    x: trap.x,
                    y: trap.y,
                    startTime: Date.now(),
                    radius: explosionRadius
                });
                
                // Check if any bot is in explosion radius
                for (let targetBot of bots) {
                    if (targetBot !== entity && targetBot.alive) {
                        const distance = Math.sqrt(Math.pow(targetBot.x - trap.x, 2) + Math.pow(targetBot.y - trap.y, 2));
                        if (distance <= explosionRadius) {
                            targetBot.alive = false;
                        }
                    }
                }
                
                // Check if player is in explosion radius
                if (!DISABLE_PLAYER && player.alive && entity !== player) {
                    const distance = Math.sqrt(Math.pow(player.x - trap.x, 2) + Math.pow(player.y - trap.y, 2));
                    if (distance <= explosionRadius) {
                        player.alive = false;
                    }
                }
            }
            
            // Clear traps
            if (entity === player) {
                playerTraps = [];
            } else {
                const botIndex = bots.indexOf(entity);
                if (botIndex !== -1) {
                    botTraps[botIndex] = [];
                }
            }
        }

        // Check for treasure collection
        function checkTreasureCollection() {
            if (!gameActive) return;
            
            for (let treasure of treasures) {
                if (!treasure.collected) {
                    // Check bots
                    for (let bot of bots) {
                        if (bot.alive && bot.x === treasure.x && bot.y === treasure.y) {
                            treasure.collected = true;
                            bot.treasures++;
                            updateUI();
                        }
                    }
                    
                    // Check player
                    if (!DISABLE_PLAYER && player.alive && player.x === treasure.x && player.y === treasure.y) {
                        treasure.collected = true;
                        player.treasures++;
                        updateUI();
                    }
                }
            }
            
            // Check if all treasures are collected
            if (treasures.every(t => t.collected)) {
                endGame("treasures_collected");
            }
            
            // Check if time is up
            if (Date.now() - gameStartTime >= GAME_DURATION) {
                endGame("time_up");
            }
            
            // Check if only one participant remains
            let aliveCount = 0;
            if (!DISABLE_PLAYER && player.alive) aliveCount++;
            aliveCount += bots.filter(b => b.alive).length;
            
            if (aliveCount === 1) {
                endGame("last_one_standing");
            }
        }

        // Update UI
        function updateUI() {
            const botsInfo = document.getElementById('botsInfo');
            botsInfo.innerHTML = '';
            
            // Show player info if enabled
            if (!DISABLE_PLAYER) {
                const playerDiv = document.createElement('div');
                playerDiv.style.color = 'blue';
                playerDiv.innerHTML = `Player: Treasures: ${player.treasures}, Traps: ${player.remainingTraps}, Status: ${player.alive ? 'Alive' : 'Dead'}`;
                botsInfo.appendChild(playerDiv);
            }
            
            // Show bots info
            for (let i = 0; i < bots.length; i++) {
                const bot = bots[i];
                const div = document.createElement('div');
                div.style.color = bot.color;
                div.innerHTML = `Bot ${i}: Treasures: ${bot.treasures}, Traps: ${bot.remainingTraps}, Status: ${bot.alive ? 'Alive' : 'Dead'}`;
                botsInfo.appendChild(div);
            }
            
            const remainingTreasures = treasures.filter(t => !t.collected).length;
            document.getElementById('remainingTreasures').textContent = remainingTreasures;
            
            // Update time remaining
            const timeRemaining = Math.max(0, GAME_DURATION - (Date.now() - gameStartTime));
            document.getElementById('timeRemaining').textContent = Math.ceil(timeRemaining / 1000);
            
            if (DEVELOPER_MODE) {
                document.getElementById('devMode').style.display = 'block';
            } else {
                document.getElementById('devMode').style.display = 'none';
            }
        }

        // End game
        async function endGame(reason) {
            gameRunning = false;
            gameActive = false; // Stop all game actions
            waitingForServer = true;
            serverResponses = 0;
            
            // Calculate winner and scores
            const scores = [];
            
            // Add player score if enabled
            if (!DISABLE_PLAYER) {
                scores.push({
                    id: 'player',
                    score: player.treasures * 10 + (player.alive ? 20 : 0),
                    treasures: player.treasures,
                    alive: player.alive
                });
            }
            
            // Add bot scores
            for (let bot of bots) {
                scores.push({
                    id: bot.id,
                    score: bot.treasures * 10 + (bot.alive ? 20 : 0),
                    treasures: bot.treasures,
                    alive: bot.alive
                });
            }
            
            scores.sort((a, b) => b.score - a.score);
            const winner = scores[0];
            
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('gameOver').textContent = `Game Over! ${winner.id === 'player' ? 'Player' : `Bot ${winner.id}`} wins with ${winner.score} points!`;
            
            // End player data collection
            if (!DISABLE_PLAYER && collectPlayerData) {
                endDataCollection(winner.id === 'player');
            }
            
            document.getElementById('serverStatus').textContent = 'Waiting for server to update bot weights...';
            
            // Send game results to server and wait for all responses
            if (USE_SERVER_BOT) {
                let allPromises = [];
                
                for (let i = 0; i < bots.length; i++) {
                    const finalState = getGameState(i);
                    finalState.game_over_reason = reason;
                    finalState.final_scores = scores;
                    finalState.winner_id = winner.id;
                    
                    let promise = fetch(`${SERVER_URL}/game_over`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(finalState)
                    })
                    .then(response => response.json())
                    .then(data => {
                        serverResponses++;
                        document.getElementById('serverStatus').textContent = 
                            `Received responses from server: ${serverResponses}/${NUM_BOTS}`;
                        return data;
                    })
                    .catch(error => {
                        console.error('Error sending game result to server:', error);
                        serverResponses++;
                        return null;
                    });
                    
                    allPromises.push(promise);
                }
                
                // Wait for all responses before restarting
                try {
                    await Promise.all(allPromises);
                    document.getElementById('serverStatus').textContent = 
                        'Server update complete! Starting new game in 3 seconds...';
                    
                    // Add a small delay to ensure server has finished processing
                    setTimeout(() => {
                        init();
                    }, 3000);
                    
                } catch (error) {
                    console.error('Error waiting for server responses:', error);
                    document.getElementById('serverStatus').textContent = 
                        'Server error! Starting new game in 5 seconds...';
                    
                    setTimeout(() => {
                        init();
                    }, 5000);
                }
            } else {
                // If not using server bot, restart immediately
                setTimeout(() => {
                    init();
                }, 5000);
            }
        }

        // Update active explosions
        function updateExplosions() {
            const currentTime = Date.now();
            activeExplosions = activeExplosions.filter(explosion => {
                return currentTime - explosion.startTime < EXPLOSION_DURATION;
            });
        }

        // Draw vision cone for an entity
        function drawVisionCone(entity) {
            const startAngle = entity.direction - visionAngle / 2;
            const endAngle = entity.direction + visionAngle / 2;
            
            ctx.beginPath();
            ctx.moveTo(entity.x * tileSize + tileSize / 2, entity.y * tileSize + tileSize / 2);
            
            for (let r = 0; r <= visionDistance; r += 0.5) {
                for (let angle = startAngle; angle <= endAngle; angle += 0.1) {
                    const checkX = Math.round(entity.x + Math.cos(angle) * r);
                    const checkY = Math.round(entity.y + Math.sin(angle) * r);
                    
                    if (checkX >= 0 && checkX < gridWidth && checkY >= 0 && checkY < gridHeight) {
                        if (hasLineOfSight(entity.x, entity.y, checkX, checkY)) {
                            const px = checkX * tileSize + tileSize / 2;
                            const py = checkY * tileSize + tileSize / 2;
                            ctx.lineTo(px, py);
                        }
                    }
                }
            }
            
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 0, 0.1)';
            ctx.fill();
        }

        // Draw game
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // If not in developer mode and player is alive, only draw what's in vision
            if (!DEVELOPER_MODE && !DISABLE_PLAYER && player.alive) {
                // Fill everything black first
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw vision cone
                drawVisionCone(player);
                
                // Draw only visible items
                // Draw visible obstacles
                ctx.fillStyle = '#666';
                for (let obstacle of obstacles) {
                    for (let ox = obstacle.x; ox < obstacle.x + obstacle.width; ox++) {
                        for (let oy = obstacle.y; oy < obstacle.y + obstacle.height; oy++) {
                            if (isInVisionCone(player, ox, oy)) {
                                ctx.fillRect(ox * tileSize, oy * tileSize, tileSize, tileSize);
                            }
                        }
                    }
                }
                
                // Draw visible treasures
                for (let treasure of treasures) {
                    if (isInVisionCone(player, treasure.x, treasure.y)) {
                        if (!treasure.collected) {
                            ctx.fillStyle = 'green';
                            ctx.beginPath();
                            ctx.moveTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize);
                            ctx.lineTo(treasure.x * tileSize + tileSize, treasure.y * tileSize + tileSize / 2);
                            ctx.lineTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize + tileSize);
                            ctx.lineTo(treasure.x * tileSize, treasure.y * tileSize + tileSize / 2);
                            ctx.closePath();
                            ctx.fill();
                        } else {
                            ctx.strokeStyle = 'lightgreen';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize);
                            ctx.lineTo(treasure.x * tileSize + tileSize, treasure.y * tileSize + tileSize / 2);
                            ctx.lineTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize + tileSize);
                            ctx.lineTo(treasure.x * tileSize, treasure.y * tileSize + tileSize / 2);
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }
                
                // Draw visible bots
                for (let bot of bots) {
                    if (bot.alive && isInVisionCone(player, bot.x, bot.y)) {
                        ctx.fillStyle = bot.color;
                        ctx.fillRect(bot.x * tileSize, bot.y * tileSize, tileSize, tileSize);
                        
                        // Draw direction indicator
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(bot.x * tileSize + tileSize / 2, bot.y * tileSize + tileSize / 2);
                        ctx.lineTo(
                            bot.x * tileSize + tileSize / 2 + Math.cos(bot.direction) * tileSize,
                            bot.y * tileSize + tileSize / 2 + Math.sin(bot.direction) * tileSize
                        );
                        ctx.stroke();
                        
                        // Draw bot ID
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(bot.id.toString(), bot.x * tileSize + tileSize / 3, bot.y * tileSize + tileSize / 1.5);
                    }
                }
                
                // Draw visible traps
                for (let trap of playerTraps) {
                    if (isInVisionCone(player, trap.x, trap.y)) {
                        ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
                        ctx.beginPath();
                        ctx.arc(trap.x * tileSize + tileSize / 2, trap.y * tileSize + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                // Always draw the player
                ctx.fillStyle = 'blue';
                ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);
                
                // Draw direction indicator
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(player.x * tileSize + tileSize / 2, player.y * tileSize + tileSize / 2);
                ctx.lineTo(
                    player.x * tileSize + tileSize / 2 + Math.cos(player.direction) * tileSize,
                    player.y * tileSize + tileSize / 2 + Math.sin(player.direction) * tileSize
                );
                ctx.stroke();
                
                // Draw 'P' for player
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('P', player.x * tileSize + tileSize / 3, player.y * tileSize + tileSize / 1.5);
                
            } else {
                // Developer mode or player disabled - draw everything
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw obstacles
                ctx.fillStyle = 'black';
                for (let obstacle of obstacles) {
                    ctx.fillRect(obstacle.x * tileSize, obstacle.y * tileSize, 
                               obstacle.width * tileSize, obstacle.height * tileSize);
                }
                
                // Draw treasures
                for (let treasure of treasures) {
                    if (!treasure.collected) {
                        ctx.fillStyle = 'green';
                        ctx.beginPath();
                        ctx.moveTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize);
                        ctx.lineTo(treasure.x * tileSize + tileSize, treasure.y * tileSize + tileSize / 2);
                        ctx.lineTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize + tileSize);
                        ctx.lineTo(treasure.x * tileSize, treasure.y * tileSize + tileSize / 2);
                        ctx.closePath();
                        ctx.fill();
                    } else {
                        ctx.strokeStyle = 'lightgreen';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize);
                        ctx.lineTo(treasure.x * tileSize + tileSize, treasure.y * tileSize + tileSize / 2);
                        ctx.lineTo(treasure.x * tileSize + tileSize / 2, treasure.y * tileSize + tileSize);
                        ctx.lineTo(treasure.x * tileSize, treasure.y * tileSize + tileSize / 2);
                        ctx.closePath();
                        ctx.stroke();
                    }
                }
                
                // Draw all traps
                // Draw bot traps
                for (let i = 0; i < botTraps.length; i++) {
                    const traps = botTraps[i];
                    ctx.fillStyle = `rgba(255, 0, 0, 0.5)`;
                    for (let trap of traps) {
                        ctx.beginPath();
                        ctx.arc(trap.x * tileSize + tileSize / 2, trap.y * tileSize + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = 'black';
                        ctx.font = '12px Arial';
                        ctx.fillText(i.toString(), trap.x * tileSize + tileSize / 3, trap.y * tileSize + tileSize / 1.5);
                        ctx.fillStyle = `rgba(255, 0, 0, 0.5)`;
                    }
                }
                
                // Draw player traps
                ctx.fillStyle = `rgba(0, 0, 255, 0.5)`;
                for (let trap of playerTraps) {
                    ctx.beginPath();
                    ctx.arc(trap.x * tileSize + tileSize / 2, trap.y * tileSize + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.font = '12px Arial';
                    ctx.fillText('P', trap.x * tileSize + tileSize / 3, trap.y * tileSize + tileSize / 1.5);
                    ctx.fillStyle = `rgba(0, 0, 255, 0.5)`;
                }
                
                // Draw all bots
                for (let bot of bots) {
                    if (bot.alive) {
                        ctx.fillStyle = bot.color;
                        ctx.fillRect(bot.x * tileSize, bot.y * tileSize, tileSize, tileSize);
                        
                        // Draw direction indicator
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(bot.x * tileSize + tileSize / 2, bot.y * tileSize + tileSize / 2);
                        ctx.lineTo(
                            bot.x * tileSize + tileSize / 2 + Math.cos(bot.direction) * tileSize,
                            bot.y * tileSize + tileSize / 2 + Math.sin(bot.direction) * tileSize
                        );
                        ctx.stroke();
                        
                        // Draw bot ID
                        ctx.fillStyle = 'white';
                        ctx.font = 'bold 12px Arial';
                        ctx.fillText(bot.id.toString(), bot.x * tileSize + tileSize / 3, bot.y * tileSize + tileSize / 1.5);
                    }
                }
                
                // Draw player
                if (!DISABLE_PLAYER && player.alive) {
                    ctx.fillStyle = 'blue';
                    ctx.fillRect(player.x * tileSize, player.y * tileSize, tileSize, tileSize);
                    
                    // Draw direction indicator
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(player.x * tileSize + tileSize / 2, player.y * tileSize + tileSize / 2);
                    ctx.lineTo(
                        player.x * tileSize + tileSize / 2 + Math.cos(player.direction) * tileSize,
                        player.y * tileSize + tileSize / 2 + Math.sin(player.direction) * tileSize
                    );
                    ctx.stroke();
                    
                    // Draw 'P' for player
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('P', player.x * tileSize + tileSize / 3, player.y * tileSize + tileSize / 1.5);
                }
            }
            
            // Draw active explosions (always visible)
            const currentTime = Date.now();
            for (let explosion of activeExplosions) {
                const elapsed = currentTime - explosion.startTime;
                const progress = elapsed / EXPLOSION_DURATION;
                
                if (progress < 1) {
                    // Fade out as time progresses
                    const alpha = 0.7 * (1 - progress);
                    ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
                    ctx.beginPath();
                    ctx.arc(
                        explosion.x * tileSize + tileSize / 2,
                        explosion.y * tileSize + tileSize / 2,
                        explosion.radius * tileSize,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }
            }
        }

        // Game loop
        function gameLoop() {
            if ((!gameRunning && !waitingForServer) || (!gameActive && !waitingForServer)) return;
            
            frameCount++;
            
            if (!waitingForServer && gameActive) {
                updateBotsFromServer();
                checkTreasureCollection();
                updateExplosions();
            }
            
            draw();
            updateUI();
            
            requestAnimationFrame(gameLoop);
        }

        // Input handling
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || DISABLE_PLAYER || !player.alive || !gameActive) return;
            
            let action = null;
            
            switch (e.key) {
                case 'ArrowUp':
                    if (move(player, 0, -1)) {
                        updateDirection(player, 0, -1);
                        action = 'move_up';
                    }
                    break;
                case 'ArrowDown':
                    if (move(player, 0, 1)) {
                        updateDirection(player, 0, 1);
                        action = 'move_down';
                    }
                    break;
                case 'ArrowLeft':
                    if (move(player, -1, 0)) {
                        updateDirection(player, -1, 0);
                        action = 'move_left';
                    }
                    break;
                case 'ArrowRight':
                    if (move(player, 1, 0)) {
                        updateDirection(player, 1, 0);
                        action = 'move_right';
                    }
                    break;
                case ' ':
                    e.preventDefault();
                    dropTrap(player, playerTraps);
                    action = 'drop_trap';
                    break;
                case 'e':
                case 'E':
                    explodeTraps(player, playerTraps);
                    action = 'explode_traps';
                    break;
            }
            
            // Record player action
            if (action) {
                recordPlayerAction(action);
            }
        });

        // Update player settings
        document.getElementById('enablePlayer').checked = !DISABLE_PLAYER;
        document.getElementById('collectData').checked = collectPlayerData;
        
        document.getElementById('collectData').addEventListener('change', (e) => {
            collectPlayerData = e.target.checked;
        });

        // Start game
        init();
        
        // Restart button handler
        document.getElementById('restartButton').addEventListener('click', () => {
            if (!waitingForServer) {
                init();
            }
        });
    </script>
</body>
</html>